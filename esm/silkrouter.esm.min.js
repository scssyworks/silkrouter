import{Observable as t,fromEvent as e}from"rxjs";const s=/:[^/]+/g,n=/^\/(?=[^?]*)/,o="vpushstate",r="?",i="",a=void 0,c=typeof i,h=typeof a,u="State",p=`push${u}`,l=`replace${u}`;function f(t,e){const n={};if(s.test(t)){const o=new RegExp(t.replace(/\//g,"\\/").replace(/:[^/\\]+/g,"([^\\/]+)"));if(s.lastIndex=0,o.test(e)){const r=Array.from(t.match(s)).map((t=>t.replace(":",i))),a=Array.from(e.match(o));a.shift(),r.forEach(((t,e)=>{n[t]=a[e]}))}}return n}function b(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var y=b((function(t){return"object"==typeof t&&null!==t}));function g(t,e,s){t.dispatchEvent(new CustomEvent(e,{bubbles:!0,cancelable:!0,detail:s||[]}))}function d(t){return typeof t===c?t.trim():i}function x(t,e){e=y(e)?e:{};const[s,c]=t.split(r),{replace:h=!1,preventDefault:u=!1,queryString:f=c,data:b,pageTitle:x=null}=e,{preservePath:m,hashRouting:v,history:w,context:R}=this.config;if(!function(t){return n.test(t)}(t=d(s)))throw new TypeError("Route format is incorrect!");{const e=t;v&&(t=`${m?"":"/"}#${t}`),t=`${t}${d(f?`${r+f}`:i)}`;const s=w.state||{idx:0};w[h?l:p]({data:b,idx:s.idx+1},x,t),!u&&e&&g(R,o,[{path:e,hash:v},a,this])}}const m=(t,e)=>d(t?e.hash.substring(1).split(r)[0]:e.pathname);class v{constructor(t,e){const[s,n,o]=t,{location:i,history:a}=o.config;this.route=s.path,this.isHashRoute=s.hash,this.router=o,this.currentEvent=n||e,this.query={path:d(i.search.substring(1)),hash:d(i.hash.split(r)[1])};const{state:c}=n||{},{data:h,idx:u=0}=c||a.state||{};this.data=h,this.index=+u}}function w(){return e=>new t((t=>{const s=e.subscribe({next:e=>{const[,,s]=e.detail;s===this&&t.next(new v(e.detail,e))},error:t.error,complete:t.complete});return()=>{s.unsubscribe()}}))}function R(e){const{hashRouting:s,location:n,init:o}=this.config,r=m(s,n);return n=>new t((t=>{const i=n.subscribe(t);return e||(e=!0,o&&r&&t.next(new v([{path:r,hash:s},a,this]))),()=>{i.unsubscribe()}}))}class E{static get global(){return typeof globalThis!==h?globalThis:global||self}constructor(t){let{history:s,context:n,location:r,hash:i}=t;if(!s[p])throw new Error("History is not supported in this environment!");this.popStateSubscription=e(E.global,"popstate").subscribe((t=>{const e=m(i,r);e&&g(n,o,[{path:e,hash:i},t,this])})),this.listeners=e(n,o).pipe(w.apply(this))}pipe(){for(var t=arguments.length,e=new Array(t),s=0;s<t;s++)e[s]=arguments[s];return this.listeners.pipe(R.apply(this),...e)}subscribe(t){return this.pipe().subscribe(t)}destroy(t){"function"==typeof t&&t(),this.popStateSubscription.unsubscribe()}}class $ extends E{constructor(t){t=y(t)?t:{};const{history:e,location:s,document:n}=E.global,o=n.body;super({history:e,location:s,context:o,hash:t.hashRouting}),this.config=Object.freeze({init:!0,hashRouting:!1,preservePath:!1,context:o,history:e,location:s,...t}),t.hashRouting&&!s.hash&&this.set("/",{replace:!0,preventDefault:!0})}set(t,e){x.apply(this,[t,e])}}export{$ as Router,E as RouterCore,f as resolveParams};
